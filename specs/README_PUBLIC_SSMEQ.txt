README — Shunyaya Symbolic Mathematical Electrical Quantities (SSMEQ)
Status: Public Research Release (v2.0)
Date: November 14, 2025
Caution: Research/observation only. Not for critical decision-making.
License: Open standard. Free to implement with no fees or registration, provided strictly “as-is” with no warranty, no endorsement, and no claim of exclusive stewardship.
Citation: "Shunyaya Symbolic Mathematical Electrical Quantities (SSMEQ)" (concept origin).

What SSMEQ Is (one-liner)

A manifest-first overlay that rides beside existing electrical telemetry and turns ordinary volts/amps/watts into zero-centric, self-checking records — without changing the raw measurements.

Core Invariants (copy-ready)

Value invariance.
Existing channels such as V_rms, I_rms, P, f, pf, THD remain untouched. SSMEQ only adds symbolic fields.

Deterministic zero-centric encoding.

e_V := ln( V_rms / V_ref )
e_I := ln( I_rms / I_ref )
e_f := ln( f / f_ref )
e_P := asinh( P / P_scale )


At anchors: e_Q = 0. Above anchors: e_Q > 0. Below anchors: e_Q < 0.

Power residual consistency.

r_P := e_P_meas - ( e_V + e_I + ln( pf / pf_ref ) )


Small, stable |r_P| implies self-consistent voltage–current–power–pf quartet; drift or jumps reveal bias or wiring issues.

Bands turn math into duty.
band_P is derived from conditions over e_*, a_*, and r_P declared in a manifest_id; actions and timing windows are explicit.

Canonical subset commitment (optional but recommended).

sha256=<hex>


computed over a published byte recipe (canonical subset of SSMEQ fields).

Continuity stamp (optional).

SSMCLOCK1|iso_utc|nonce=<...>|sha256=<canonical_subset>|prev=<prior_sha256_or_sentinel>


makes reordering and deletion visible in evidence chains.

Minimal SSMEQ Record (illustrative shape)
{
  timestamp,          // UTC time of measurement
  channel_id,         // feeder, phase, transformer, etc.

  V_rms, I_rms, P, f, pf, THD,   // existing telemetry (unchanged)

  e_V, e_I, e_f, e_P,            // zero-centric lenses
  r_P,                           // power residual
  band_P,                        // health band from manifest
  manifest_id,                   // pointer to SSMEQ rulebook

  sha256,                        // optional canonical subset commitment
  stamp                          // optional continuity stamp (SSMCLOCK1|...)
}


Payload invariance: raw telemetry fields remain exactly as generated by your meters; SSMEQ lives in parallel lanes.

Canonical Subset (byte recipe — summary)

Fields.
A compact, fixed-order list of SSMEQ fields chosen for commitment, for example:

[timestamp, channel_id, e_V, e_I, e_P, r_P, band_P, manifest_id]


Hashing.

bytes  := JOIN_WITH_NEWLINES([
  timestamp,
  channel_id,
  e_V,
  e_I,
  e_P,
  r_P,
  band_P,
  manifest_id
])
sha256 := SHA256(bytes)   // 64-hex HEAD


Stamp.
Insert the HEAD into a stamp as sha256=<HEAD>.

Continuity.
Next SSMEQ record sets prev=<prior_HEAD> inside the next stamp, forming a tamper-evident chain.

The exact recipe (ordering, whitespace, newline, encoding) is published in the SSMEQ canonical subset note and bound in the manifest.

Manifest & Bands (policy — summary)

manifest_id names the active electrical rulebook.
It declares: V_ref, I_ref, f_ref, pf_ref, P_scale, THD_ref, lens formulas, residuals, band logic, and canonical subset rules.

Cutpoints and conditions define labeled ranges.
For example (illustrative):

RED   : abs(r_P) > 0.10           or abs(a_pf) > 0.7
AMBER : 0.03 < abs(r_P) <= 0.10   and abs(a_pf) <= 0.7
GREEN : abs(r_P) <= 0.03          and abs(a_pf) <= 0.3


Windows and actions.
Each band carries action codes like continue, monitor_and_plan, investigate_immediately plus window_s and escalation_owner.

Determinism.
Identical inputs (V_rms, I_rms, P, f, pf, THD) under the same manifest_id must yield identical e_*, r_P, and band_P.

One-Minute Acceptance (receiver / intermediary)

When consuming SSMEQ records:

Check structure.

Required SSMEQ fields present (e_V, e_I, e_P, r_P, band_P, manifest_id).

Recompute symbolic lanes.

Using manifest lenses and anchors, recompute e_V, e_I, e_f, e_P and r_P on sample rows.

Confirm that published values match to within declared rounding rules.

Verify band consistency.

Apply manifest band conditions to e_*, a_*, and r_P.

Confirm that the declared band_P is what the manifest prescribes.

Canonical subset and sha256 (if present).

recomputed_sha256 := SHA256(canonical_subset_bytes)
recomputed_sha256 == sha256  // must hold if evidence mode is enabled


Continuity (if stamp present).

Parse SSMCLOCK1|iso_utc|nonce=...|sha256=...|prev=....

Check prev equals the prior record’s canonical sha256 in this chain.

Confirm iso_utc is within allowed skew and non-decreasing.

Enforce disclosure.

Ensure fields exposed match the manifest’s disclosure rules.

Evidence & Parity (operational notes)

Envelope log.
Maintain a newline-delimited ledger of canonical subset lines (for example, each SSMEQ canonical subset per line).

Hash list.
Maintain a ledger of sha256 HEAD values, in order.

Checkpoint.
Periodically store a single line such as HEAD=<64-hex> representing the last digest — useful for independent parity checks.

Parity script.
Use a simple verification script that:

- recomputes SHA256 over the envelope log,
- compares against the hash list,
- checks continuity of prev links and stamps,
- prints: ALL CHECKS PASSED (or a structured failure report).


This pattern mirrors other Shunyaya projects so that a single parity script style can audit multiple domains.

Quickstart (micro flow)

Declare a manifest.

Fix V_ref, I_ref, f_ref, pf_ref, P_scale, THD_ref.

Publish lens formulas and r_P definition.

Define band_P logic.

Compute symbolic lanes.

e_V := ln( V_rms / V_ref )
e_I := ln( I_rms / I_ref )
e_P := asinh( P / P_scale )
r_P := e_P_meas - ( e_V + e_I + ln( pf / pf_ref ) )


Assign bands.

Map e_*, a_*, and r_P to band_P using manifest conditions.

Build canonical subset and sha256.

Use the published recipe to build bytes; compute sha256.

Emit SSMEQ record.

Add e_*, r_P, band_P, manifest_id, and optionally sha256 and stamp.

On next record in the chain, set prev in the stamp to the last sha256.

Verify at the receiver using the one-minute checklist above.

Security & Interop Hints

Keep canonical subsets small and stable.
Changing the recipe requires a new manifest_id.

Treat manifests as auditable rulebooks.
They can be signed, published, or versioned under your internal governance.

Prefer additive deployment.
Start by adding SSMEQ fields to existing logs or message buses before wiring bands into automation.

Protect channels where needed.
For sensitive deployments, run SSMEQ records over secure channels; the stamps add evidence, not encryption.

Changes in this release (summary)

Explicit anchors and lens formulas for e_V, e_I, e_f, and e_P aligned with the broader Shunyaya framework.

Power residual r_P formally defined and treated as a first-class health indicator.

Band semantics clarified in terms of conditions over e_*, a_*, and r_P.

Canonical subset and stamp patterns harmonized with other Shunyaya symbolic projects for cross-domain parity checks.

Attachment Index (this release package)

This public README is typically accompanied by:

Executive brief — short overview of SSMEQ purpose, invariants, and benefits.

Full SSMEQ spec — detailed definitions for anchors, lenses, dials, residuals, and worked examples.

Spec supplements (text / JSON):

Canonical subset recipe (how to build the committed byte stream).

Getting started guide (Day-1 / Day-7 / Day-30 adoption).

Manifest and bands note (policy and duty mapping).

Output examples (sample SSMEQ records and chains).

Stamp specification (SSM-Clock continuity format for SSMEQ).

Public README (this document).

Evidence bundle (optional, for parity):

Manifest snapshot.

Canonical subset ledger (envelopes).

Hash list.

Checkpoint line.

Verification script.

Names and packaging details are deployment-specific; the structure above is the recommended pattern.

How To Verify Locally (quick parity check)

Collect evidence files produced by your SSMEQ pipeline: manifest snapshot, canonical subset ledger, hash list, checkpoint, and verification script.

Place all evidence files in the same directory.

Run the verification script (for example, a shell or Python script included with the bundle).

Expect output similar to:

ALL CHECKS PASSED

plus any continuity and manifest notes. Deviations should be reported as explicit failure reasons.

One-Line Takeaway
Keep your electrical measurements exactly as they are — add a small symbolic lane that makes their story zero-centric, self-consistent, and independently verifiable.